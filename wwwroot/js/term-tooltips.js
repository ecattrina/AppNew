// Словарь терминов с определениями
const termDefinitions = {
    'бит': 'Бит (binary digit) - минимальная единица информации, принимающая значение 0 или 1.',
    'позиция': 'Позиция - номер места бита в кодовой комбинации, обычно нумерация начинается с 1 или 0.',
    'полином': 'Полином - математическое выражение вида a₀ + a₁x + a₂x² + ... + aₙxⁿ, где коэффициенты aᵢ принимают значения 0 или 1 в поле GF(2).',
    'синдром': 'Синдром - остаток от деления принятого полинома на порождающий многочлен, используется для обнаружения и исправления ошибок.',
    'кодовая комбинация': 'Кодовая комбинация - последовательность битов, представляющая закодированное сообщение с добавленными контрольными битами.',
    'информационная комбинация': 'Информационная комбинация - исходная последовательность битов данных, подлежащая кодированию.',
    'порождающий многочлен': 'Порождающий многочлен g(x) - многочлен, используемый для генерации кодовых комбинаций циклического кода.',
    'контрольный бит': 'Контрольный бит (бит четности) - дополнительный бит, добавляемый к данным для обнаружения и исправления ошибок.',
    'бит четности': 'Бит четности - контрольный бит, значение которого выбирается так, чтобы сумма контролируемых битов была четной (по модулю 2).',
    'вероятность безотказной работы': 'Вероятность безотказной работы P(t) - вероятность того, что объект будет работать безотказно в течение времени t.',
    'вероятность отказов': 'Вероятность отказов F(t) - вероятность того, что объект откажет в течение времени t. F(t) = 1 - P(t).',
    'плотность распределения отказов': 'Плотность распределения отказов f(t) - производная функции распределения отказов, показывает интенсивность отказов в единицу времени.',
    'интенсивность отказов': 'Интенсивность отказов λ(t) - условная плотность вероятности отказа объекта в момент t при условии, что до этого момента отказ не произошел.',
    'отказ': 'Отказ - событие, заключающееся в нарушении работоспособности объекта.',
    'надежность': 'Надежность - свойство объекта выполнять требуемые функции в заданных условиях в течение заданного периода времени.',
    'код хэмминга': 'Код Хэмминга - линейный блочный код, способный обнаруживать и исправлять одиночные ошибки. Контрольные биты располагаются на позициях, являющихся степенями двойки.',
    'циклический код': 'Циклический код - линейный блочный код, обладающий свойством цикличности: циклический сдвиг любой кодовой комбинации также является кодовой комбинацией.',
    'деление по модулю 2': 'Деление по модулю 2 - арифметическая операция в поле GF(2), где сложение и вычитание эквивалентны операции XOR (исключающее ИЛИ).',
    'gf(2)': 'GF(2) - поле Галуа из двух элементов {0, 1}, в котором операции сложения и вычитания выполняются по модулю 2 (XOR).',
    'остаток': 'Остаток - результат операции деления полинома на другой полином в поле GF(2).',
    'информационный полином': 'Информационный полином m(x) - полином, коэффициенты которого соответствуют информационным битам.',
    'кодовый полином': 'Кодовый полином c(x) - полином, представляющий закодированную комбинацию, включающую информационные и контрольные биты.',
    'степень полинома': 'Степень полинома - наивысшая степень переменной x с ненулевым коэффициентом в полиноме.',
    'коэффициент': 'Коэффициент - числовое значение, стоящее перед переменной в полиноме. В кодах принимает значения 0 или 1.',
    'модуль 2': 'Модуль 2 - арифметическая операция, при которой результат берется по остатку от деления на 2 (0 или 1).',
    'инверсия': 'Инверсия бита - изменение значения бита на противоположное (0 → 1, 1 → 0).',
    'контрольная сумма': 'Контрольная сумма - сумма битов по модулю 2, используемая для проверки корректности данных.',
    'таблица синдромов': 'Таблица синдромов - таблица соответствия между позициями ошибок и их синдромами, используется для быстрого определения позиции ошибки.'
};

// Функция для поиска и выделения терминов в тексте
function initializeTermTooltips() {
    // Список терминов, отсортированный по длине (от длинных к коротким), чтобы сначала находить составные термины
    const sortedTerms = Object.keys(termDefinitions).sort((a, b) => b.length - a.length);
    
    // Функция для обертывания термина в span с tooltip
    function wrapTerm(text, term, definition) {
        const regex = new RegExp(`\\b${term}\\b`, 'gi');
        return text.replace(regex, (match) => {
            // Проверяем, не находится ли термин уже внутри другого span
            if (match.includes('<span')) return match;
            
            return `<span class="term-tooltip" data-bs-toggle="tooltip" data-bs-placement="top" title="${definition.replace(/"/g, '&quot;')}">${match}</span>`;
        });
    }
    
    // Обрабатываем все элементы с классом .card-body и другие текстовые блоки
    const containers = document.querySelectorAll('.card-body, .alert, p, li, td, th, h5, h6');
    
    containers.forEach(container => {
        // Пропускаем элементы, которые уже обработаны или содержат формы
        if (container.closest('form') || container.querySelector('.term-tooltip')) {
            return;
        }
        
        // Обрабатываем только текстовые узлы
        const walker = document.createTreeWalker(
            container,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );
        
        const textNodes = [];
        let node;
        while (node = walker.nextNode()) {
            if (node.textContent.trim().length > 0) {
                textNodes.push(node);
            }
        }
        
        textNodes.forEach(textNode => {
            let text = textNode.textContent;
            let modified = false;
            
            // Проверяем каждый термин
            for (const term of sortedTerms) {
                const regex = new RegExp(`\\b${term}\\b`, 'gi');
                if (regex.test(text)) {
                    text = wrapTerm(text, term, termDefinitions[term.toLowerCase()]);
                    modified = true;
                }
            }
            
            if (modified) {
                const wrapper = document.createElement('span');
                wrapper.innerHTML = text;
                textNode.parentNode.replaceChild(wrapper, textNode);
            }
        });
    });
    
    // Инициализируем Bootstrap tooltips
    const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    tooltipTriggerList.map(function (tooltipTriggerEl) {
        return new bootstrap.Tooltip(tooltipTriggerEl, {
            html: true,
            trigger: 'hover focus'
        });
    });
}

// Запускаем при загрузке страницы
document.addEventListener('DOMContentLoaded', function() {
    initializeTermTooltips();
});

